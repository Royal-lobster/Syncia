var ge=Object.create;var P=Object.defineProperty;var Be=Object.getOwnPropertyDescriptor;var ce=Object.getOwnPropertyNames;var me=Object.getPrototypeOf,be=Object.prototype.hasOwnProperty;var he=(n,s)=>{for(var c in s)P(n,c,{get:s[c],enumerable:!0})},ee=(n,s,c,p)=>{if(s&&typeof s=="object"||typeof s=="function")for(let f of ce(s))!be.call(n,f)&&f!==c&&P(n,f,{get:()=>s[f],enumerable:!(p=Be(s,f))||p.enumerable});return n};var K=(n,s,c)=>(c=n!=null?ge(me(n)):{},ee(s||!n||!n.__esModule?P(c,"default",{value:n,enumerable:!0}):c,n)),ve=n=>ee(P({},"__esModule",{value:!0}),n);var Ce={};he(Ce,{default:()=>Ee});module.exports=ve(Ce);var pe=require("@parcel/plugin");var W=typeof globalThis.process<"u"?globalThis.process.argv:[];var te=()=>typeof globalThis.process<"u"?globalThis.process.env:{};var Ne=new Set(W),ne=n=>Ne.has(n),De=W.filter(n=>n.startsWith("--")&&n.includes("=")).map(n=>n.split("=")).reduce((n,[s,c])=>(n[s]=c,n),{});var Ke=ne("--dry-run"),U=()=>ne("--verbose")||te().VERBOSE==="true",Me=U();var Ie=(n="",...s)=>console.log(n.padEnd(9),"|",...s);var Ae=0,de=(...n)=>U()&&Ie(`\u{1F7E1} ${Ae++}`,...n);var G=require("@parcel/graph"),w=require("@parcel/utils"),A=K(require("assert")),y=K(require("nullthrows"));function X(n,s){return n.type===s.type&&n.env.context===s.env.context&&n.bundleBehavior==null&&s.bundleBehavior==null}var j=K(require("nullthrows"));function k(n){if(n.asset==null)return{uniqueKey:n.uniqueKey,assets:new Set,internalizedAssetIds:[],mainEntryAsset:null,size:0,sourceBundles:new Set,target:n.target,type:(0,j.default)(n.type),env:(0,j.default)(n.env),needsStableName:!!n.needsStableName,bundleBehavior:n.bundleBehavior};let s=(0,j.default)(n.asset);return{uniqueKey:n.uniqueKey,assets:new Set([s]),internalizedAssetIds:[],mainEntryAsset:s,size:s.stats.size,sourceBundles:new Set,target:n.target,type:n.type??s.type,env:n.env??s.env,needsStableName:!!n.needsStableName,bundleBehavior:n.bundleBehavior??s.bundleBehavior}}var oe=K(require("nullthrows"));function Y(n,s){return s.getNodeIdsConnectedTo(s.getNodeIdByContentKey(n.id)).map(c=>(0,oe.default)(s.getNode(c)))}var $=K(require("assert")),H=K(require("nullthrows"));function J(n,s,c){let p=(0,H.default)(n.getNode(s));(0,$.default)(p!=="root");for(let f of p.assets){c.set(f,c.get(f).filter(N=>!N.includes(p)));for(let N of p.sourceBundles){let z=(0,H.default)(n.getNode(N));(0,$.default)(z!=="root"),z.assets.add(f),z.size+=f.stats.size}}n.removeNode(s)}var V={sync:1,parallel:2,lazy:3};function le(n,s,c){let p=new Map,f=new Map,N=new G.ContentGraph,z=new w.DefaultMap(()=>[]),t=new G.Graph,i=[],S={parallel:1,lazy:2},m=new G.ContentGraph,I=new Set,v=new G.ContentGraph,D=(0,y.default)(m.addNode("root")),M=(0,y.default)(t.addNode("root"));m.setRootNodeId(D),t.setRootNodeId(M);for(let[e,o]of c){let g=k({asset:e,target:(0,y.default)(o.target),needsStableName:o.isEntry}),l=t.addNode(g);f.set(e.id,l),p.set(e,[l,l]),m.addEdge(D,m.addNodeByContentKey(e.id,e)),t.addEdge(M,l),N.addEdge(N.addNodeByContentKeyIfNeeded(o.id,{value:o,type:"dependency"}),N.addNodeByContentKeyIfNeeded(String(l),{value:g,type:"bundle"}),V[o.priority]),I.add(l)}let q=[],_=new Set;n.traverse({enter(e,o,g){if(e.type==="asset"){if(o?.type==="dependency"&&o?.value.isEntry&&!c.has(e.value))return g.skipChildren(),e;q.push(e.value);let l=p.get(e.value);l&&l[0]===l[1]?i.push([e.value,l[0]]):l&&i.push([e.value,i[i.length-1][1]])}else if(e.type==="dependency"){if(o==null)return e;let l=e.value;if(n.isDependencySkipped(l))return g.skipChildren(),e;(0,A.default)(o?.type==="asset");let b=o.value,a=n.getDependencyAssets(l);if(a.length===0)return e;for(let r of a){if(l.priority==="lazy"||r.bundleBehavior==="isolated"){let d=f.get(r.id),u;if(d==null){let h=(0,y.default)(t.getNode(i[0][1]));(0,A.default)(h!=="root"),u=k({asset:r,target:h.target,needsStableName:l.bundleBehavior==="inline"||r.bundleBehavior==="inline"?!1:l.isEntry||l.needsStableName,bundleBehavior:l.bundleBehavior??r.bundleBehavior}),d=t.addNode(u),f.set(r.id,d),p.set(r,[d,d]),I.add(d),t.addEdge(M,d)}else u=(0,y.default)(t.getNode(d)),(0,A.default)(u!=="root"),l.bundleBehavior==="isolated"&&u.bundleBehavior==null&&(u.bundleBehavior=l.bundleBehavior);N.addEdge(N.addNodeByContentKeyIfNeeded(l.id,{value:l,type:"dependency"}),N.addNodeByContentKeyIfNeeded(String(d),{value:u,type:"bundle"}),V[l.priority]);continue}if(b.type!==r.type||l.priority==="parallel"||r.bundleBehavior==="inline"){let[d,u]=(0,y.default)(i[i.length-1]),h=(0,y.default)(t.getNode(u));(0,A.default)(h!=="root");let B,R=(0,y.default)(p.get(d))[0],T=(0,y.default)(t.getNode(R));(0,A.default)(T!=="root");let E;B=f.get(r.id);let F=(0,y.default)(h.mainEntryAsset);c.has(F)&&X(F,r)&&l.bundleBehavior==null&&(B=u),B==null?(E=k({asset:r,type:r.type,env:r.env,bundleBehavior:l.bundleBehavior??r.bundleBehavior,target:T.target,needsStableName:r.bundleBehavior==="inline"||l.bundleBehavior==="inline"||l.priority==="parallel"&&!l.needsStableName?!1:T.needsStableName}),B=t.addNode(E),b.type!==r.type&&_.add(B)):(E=t.getNode(B),(0,A.default)(E!=null&&E!=="root"),l.bundleBehavior==="isolated"&&E.bundleBehavior==null&&(E.bundleBehavior=l.bundleBehavior)),f.set(r.id,B),p.set(r,[B,u]),t.addEdge(R,B),B!=u&&N.addEdge(N.addNodeByContentKeyIfNeeded(l.id,{value:l,type:"dependency"}),N.addNodeByContentKeyIfNeeded(String(B),{value:E,type:"bundle"}),V.parallel),z.get(r).push([l,E]);continue}}}return e},exit(e){i[i.length-1]?.[0]===e.value&&i.pop()}},void 0);for(let[e,o]of t.nodes){if(!_.has(e)||o==="root")continue;let g=Z(e);for(let[l,b]of t.nodes)if(o!=="root"&&b!=="root"&&o!==b&&_.has(l)&&X(o,b)){let a=Z(l);if((0,w.setEqual)(a,g)){let r=!0;for(let d of N.getNodeIdsConnectedTo(N.getNodeIdByContentKey(String(l)),G.ALL_EDGE_TYPES)){let u=N.getNode(d);if(u&&u.type==="dependency"&&u.value.specifierType==="url"){r=!1;continue}}if(!r)continue;ye(e,l)}}}for(let[e]of p)c.has(e)||m.addNodeByContentKey(e.id,e);for(let[e]of p){let o=v.addNodeByContentKeyIfNeeded(e.id,e);n.traverse((g,l,b)=>{if(g.value===e)return;if(g.type==="dependency"){let d=g.value;if(N.hasContentKey(d.id)&&d.priority!=="sync"){let u=n.getDependencyAssets(d);if(u.length===0)return;(0,A.default)(u.length===1);let h=u[0],B=(0,y.default)(t.getNode((0,y.default)(f.get(h.id))));B!=="root"&&B.bundleBehavior==null&&!B.env.isIsolated()&&B.env.context===e.env.context&&m.addEdge(m.getNodeIdByContentKey(e.id),m.getNodeIdByContentKey(h.id),d.priority==="parallel"?S.parallel:S.lazy)}d.priority!=="sync"&&b.skipChildren();return}let a=g.value;if(a.bundleBehavior!=null||e.type!==a.type){b.skipChildren();return}let r=v.addNodeByContentKeyIfNeeded(g.value.id,g.value);v.addEdge(o,r)},e)}let L=new Map;for(let e of c.keys())L.set(e,new Set);for(let e of m.topoSort(G.ALL_EDGE_TYPES)){let o=m.getNode(e);if(o==="root")continue;(0,A.default)(o!=null);let g=(0,y.default)(p.get(o))[1],l;if(o.bundleBehavior==="isolated")l=new Set;else{l=new Set(L.get(o));for(let r of[g,...t.getNodeIdsConnectedFrom(g)]){let d=(0,y.default)(t.getNode(r));if((0,A.default)(d!=="root"),d.bundleBehavior==null)for(let u of d.assets){let h=v.getNodeIdsConnectedFrom(v.getNodeIdByContentKey(u.id)).map(B=>(0,y.default)(v.getNode(B)));for(let B of[u,...h])l.add(B)}}}let b=m.getNodeIdsConnectedFrom(e,G.ALL_EDGE_TYPES),a=new Set;for(let r of b){let d=m.getNode(r);if((0,A.default)(d!=="root"&&d!=null),O(d).bundleBehavior!=null)continue;let h=m.hasEdge(e,r,S.parallel),B=L.get(d),R=h?(0,w.setUnion)(a,l):l;if(B!=null?(0,w.setIntersect)(B,R):L.set(d,new Set(R)),h){let T=v.getNodeIdsConnectedFrom(v.getNodeIdByContentKey(d.id)).map(E=>(0,y.default)(v.getNode(E)));a=(0,w.setUnion)(a,T),a.add(d)}}}for(let[e,o]of m.nodes){if(o==="root")continue;let g=m.getNodeIdsConnectedTo(e,G.ALL_EDGE_TYPES).map(b=>(0,y.default)(m.getNode(b))),l=O(o).bundleBehavior!=="isolated";if(g.length!==0){for(let b of g){if(b==="root"){l=!1;continue}if(v.hasEdge(v.getNodeIdByContentKey(b.id),v.getNodeIdByContentKey(o.id))||L.get(b)?.has(o)){let a=t.getNode((0,y.default)(f.get(b.id)));(0,A.default)(a!=null&&a!=="root"),a.internalizedAssetIds.push(o.id)}else l=!1}l&&Q(o)}}for(let e of q){let o=Y(e,v).reverse(),g=[],l=[];for(let a of o)c.has(a)||!a.isBundleSplittable||O(a).needsStableName||O(a).bundleBehavior==="isolated"?g.push(a):l.push(a);o=l,o=o.filter(a=>!L.get(a)?.has(e));let b=new Set;for(let a of o){let r=(0,y.default)(f.get(a.id));if(a.env.isIsolated())continue;let d=f.get(e.id);if(d!=null){b.add(a),t.addEdge(r,d);let u=t.getNode(d);(0,A.default)(u!=="root"&&u!=null),u.sourceBundles.add(r)}else for(let u of o){if(a===u)continue;if(Y(u,v).filter(B=>!L.get(B)?.has(u)).includes(a)){let B=(0,y.default)(f.get(u.id));b.add(a),t.addEdge((0,y.default)(f.get(a.id)),B);let R=t.getNode(B);(0,A.default)(R!=="root"&&R!=null),R.sourceBundles.add(r)}}}o=o.filter(a=>!b.has(a));for(let a of g){let r=(0,y.default)(f.get(a.id)),d=(0,y.default)(t.getNode(r));(0,A.default)(d!=="root"),d.assets.add(e),d.size+=e.stats.size}if(o.length>s.minBundles){let a=o.map(h=>(0,y.default)(f.get(h.id))),r=o.map(h=>h.id).join(","),d=f.get(r),u;if(d==null){let h=(0,y.default)(t.getNode(a[0]));(0,A.default)(h!=="root"),u=k({target:h.target,type:h.type,env:h.env}),u.sourceBundles=new Set(a);let B=new Set(h.internalizedAssetIds);for(let R of a){let T=(0,y.default)(t.getNode(R));(0,A.default)(T!=="root"),T!==h&&(0,w.setIntersect)(B,new Set(T.internalizedAssetIds))}u.internalizedAssetIds=[...B],d=t.addNode(u),f.set(r,d)}else u=(0,y.default)(t.getNode(d)),(0,A.default)(u!=="root");u.assets.add(e),u.size+=e.stats.size;for(let h of a)d!==h&&t.addEdge(h,d);N.addNodeByContentKeyIfNeeded(String(d),{value:u,type:"bundle"})}else if(o.length<=s.minBundles)for(let a of o){let r=(0,y.default)(t.getNode((0,y.default)(f.get(a.id))));(0,A.default)(r!=="root"),r.assets.add(e),r.size+=e.stats.size}}for(let[e,o]of t.nodes)o!=="root"&&o.sourceBundles.size>0&&o.mainEntryAsset==null&&o.size<s.minBundleSize&&J(t,e,z);for(let e of t.getNodeIdsConnectedFrom(D)){let o=e,g=fe(o);if(g.length>s.maxParallelRequests){let l=g.filter(r=>{let d=(0,y.default)(t.getNode(r));return d!=="root"&&d.sourceBundles.size>0&&o!=r}),b=g.length,a=l.map(r=>({id:r,bundle:(0,y.default)(t.getNode(r))})).map(({id:r,bundle:d})=>((0,A.default)(d!=="root"),{id:r,bundle:d})).sort((r,d)=>d.bundle.size-r.bundle.size);for(;a.length>0&&b>s.maxParallelRequests;){let r=a.pop(),d=r.bundle,u=r.id,h=[...d.sourceBundles].filter(B=>g.includes(B));for(let B of h){let R=(0,y.default)(t.getNode(B));(0,A.default)(R!=="root"),d.sourceBundles.delete(B);for(let E of d.assets)R.assets.add(E),R.size+=E.stats.size;for(let E of t.getNodeIdsConnectedFrom(u)){let F=t.getNode(E);(0,A.default)(F!=="root"&&F!=null),F.sourceBundles.add(B),t.addEdge(B,E)}if(t.getNodeIdsConnectedTo(u).length<=2&&d.mainEntryAsset==null){J(t,u,z);break}else t.removeEdge(B,u)}b--}}}function Q(e){t.removeNode((0,y.default)(f.get(e.id))),p.delete(e),f.delete(e.id),v.hasContentKey(e.id)&&v.replaceNodeIdsConnectedTo(v.getNodeIdByContentKey(e.id),[]),m.hasContentKey(e.id)&&m.removeNode(m.getNodeIdByContentKey(e.id))}function Z(e){let o=new Set;return t.traverseAncestors(e,g=>{t.getNodeIdsConnectedTo(g).includes(t.rootNodeId)&&o.add(g)}),o}function fe(e){let o=[];return t.traverse(g=>{o.push(g)},e),o}function ye(e,o){let g=(0,y.default)(t.getNode(e)),l=(0,y.default)(t.getNode(o));(0,A.default)(g!=="root"&&l!=="root");let b=(0,y.default)(l.mainEntryAsset),a=(0,y.default)(g.mainEntryAsset);for(let d of g.assets)l.assets.add(d);g.assets=l.assets;for(let d of N.getNodeIdsConnectedTo(N.getNodeIdByContentKey(String(o)),G.ALL_EDGE_TYPES))N.replaceNodeIdsConnectedTo(d,[N.getNodeIdByContentKey(String(e))]);for(let d of z.get(b))d[1]=g;for(let d of t.getNodeIdsConnectedTo(o))t.addEdge(d,e);Q(b);let r=(0,y.default)(p.get(a))[1];p.set(b,[e,r]),f.set(b.id,e)}function O(e){let o=t.getNode((0,y.default)(p.get(e))[0]);return(0,A.default)(o!=="root"&&o!=null),o}return{bundleGraph:t,dependencyBundleGraph:N,bundleGroupBundleIds:I,assetReference:z}}var re=require("@parcel/graph"),x=K(require("assert")),C=K(require("nullthrows"));function se(n,s){let c=new Map,{bundleGraph:p,dependencyBundleGraph:f,bundleGroupBundleIds:N}=n,z=new Map;for(let[t,i]of p.nodes){if(i==="root")continue;let S=i.mainEntryAsset,m,I;if(N.has(t)){let v=f.getNodeIdsConnectedTo(f.getNodeIdByContentKey(String(t)),re.ALL_EDGE_TYPES).map(D=>{let M=(0,C.default)(f.getNode(D));return(0,x.default)(M.type==="dependency"),M.value});for(let D of v)m=s.createBundleGroup(D,i.target);(0,x.default)(m),z.set(t,m),I=(0,C.default)(s.createBundle({entryAsset:(0,C.default)(S),needsStableName:i.needsStableName,bundleBehavior:i.bundleBehavior,target:i.target})),s.addBundleToBundleGroup(I,m)}else i.sourceBundles.size>0&&!i.mainEntryAsset?I=(0,C.default)(s.createBundle({uniqueKey:[...i.assets].map(v=>v.id).join(",")+[...i.sourceBundles].join(","),needsStableName:i.needsStableName,bundleBehavior:i.bundleBehavior,type:i.type,target:i.target,env:i.env})):i.uniqueKey!=null?I=(0,C.default)(s.createBundle({uniqueKey:i.uniqueKey,needsStableName:i.needsStableName,bundleBehavior:i.bundleBehavior,type:i.type,target:i.target,env:i.env})):((0,x.default)(S!=null),I=(0,C.default)(s.createBundle({entryAsset:S,needsStableName:i.needsStableName,bundleBehavior:i.bundleBehavior,target:i.target})));c.set(i,I);for(let v of i.assets)s.addAssetToBundle(v,I)}for(let[,t]of p.nodes){if(t==="root")continue;let i=(0,C.default)(c.get(t));if(t.internalizedAssets)for(let S of t.internalizedAssets.values()){let m=s.getIncomingDependencies(S);for(let I of m)I.priority==="lazy"&&I.specifierType!=="url"&&i.hasDependency(I)&&s.internalizeAsyncDependency(i,I)}}p.traverse((t,i,S)=>{if(p.getNode(t)==="root")return;S.skipChildren();let I=p.getNodeIdsConnectedFrom(t),v=(0,C.default)(p.getNode(t));(0,x.default)(v!=="root");let D=(0,C.default)(c.get(v));for(let M of I){let q=(0,C.default)(p.getNode(M));(0,x.default)(q!=="root");let _=(0,C.default)(c.get(q));s.createBundleReference(D,_)}});for(let[t,i]of n.assetReference)for(let[S,m]of i){let I=(0,C.default)(c.get(m));s.createAssetReference(S,t,I)}for(let{from:t,to:i}of p.getAllEdges()){let S=(0,C.default)(p.getNode(t));if(S==="root")continue;(0,x.default)(S!=="root");let m=(0,C.default)(c.get(S)),I=(0,C.default)(p.getNode(i));if(I==="root")continue;(0,x.default)(I!=="root");let v=(0,C.default)(c.get(I));s.createBundleReference(m,v)}}var ae=require("@parcel/utils"),ue=K(require("assert"));function ie(n){let s=new ae.DefaultMap(()=>new Map);return n.traverse({enter(c,p,f){return c.type!=="asset"||((0,ue.default)(p!=null&&p.type==="dependency"&&p.value.isEntry&&p.value.target!=null),s.get(p.value.target.distDir).set(c.value,p.value),f.skipChildren()),c}},void 0),s}var Se={minBundles:1e9,minBundleSize:2400,maxParallelRequests:20},Ee=new pe.Bundler({loadConfig({options:n}){return Se},bundle({bundleGraph:n,config:s}){de("@plasmohq/parcel-bundler");let c=ie(n),p=[];for(let f of c.values())p.push(le(n,s,f));for(let f of p)se(f,n)},optimize(){}});
